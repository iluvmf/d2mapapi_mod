# d2mapapi_mod
**d2mapapi mod, original from [jcageman/d2mapapi](https://github.com/jcageman/d2mapapi)**

# Projects
* `d2mapapi`: basic library for generating map data
* `d2mapapi_httpd`: httpd server, depends on `d2mapapi`
* `d2mapapi_piped`: pipe query server, depends on `d2mapapi`
* `d2mapapi_pipehost`: pipe querying library for communicating with `d2mapapi_piped`
* `d2mapapi_host`: example and test project for do pipe query using `d2mapapi_pipehost`

# Usage for `d2mapapi_httpd`
* command line: `d2mapapi_httpd [d2_path]`
  * `d2_path` is an optional parameter, which set legacy Diablo II v1.13c installation path, `d2mapapi_httpd` will search registry for installation path if this parameter is absent or does not point to a correct installed game path.
* http server is listen on port `8000`
* http url is in RESTful form:
  * `http://localhost:8000/{seed}/{difficulty}/{map}/{indentation}`
    * `{seed}`: d2 map seed
    * `{difficulty}`: game difficulty
      * 0: normal
      * 1: nightmare
      * 2: hell
    * `{map}`: map area id
    * `{indentation}`: optional field, JSON indentation spaces. JSON will be compactly encoded if this is not set
* returns the JSON data described below

# Usage for `d2mapapi_piped`
* command line: `d2mapapi_httpd [d2_path]`
  * `d2_path` is an optional parameter, which set legacy Diablo II v1.13c installation path, `d2mapapi_httpd` will search registry for installation path if this parameter is absent or does not point to a correct installed game path.
* use `PipedChildProcess::start()` to run the child process, you can pass `d2_path` as its second parameter, or pass `nullptr` for reading from registry.
* use `PipedChildProcess::queryMapRaw()` to get the encoded JSON(described below) for map data.
* use `PipedChildProcess::queryMap()` to get the decoded map data.
  * Note: you should delete the returned `CollisionMap*` pointer while it is no more needed.

# JSON structure for map data
* encoded JSON data are generated by `d2mapapi::CollisionMap::encode()` and returned by `d2mapapi_httpd` and `d2mapapi_piped`
* use `d2mapapi::CollisionMap::CollisionMap(const std::string&)` to build map data from encoded JSON
* ```
  {
    # map id
    "id": 1,
    # map offset in whole act
    "offset": ["x": 5520, "y": 5880],
    # map size
    "size": ["width": 280, "height": 200],
    # crop area of map data
    "crop": ["x0": 0, "x1": 280, "y0": 0, "y1": 200],
    # mapData is an encoded array with area in [x0, y0]-[x1, y1]
    # check description below to see how are map data encoded
    "mapData": [1,5,1,-1,
                2,3,2,-1,
                1,5,1,-1],
    # map exits
    "exits": {
      # exit to map id 2
      "2": {
        # this is not a portal (so that you can walk between the map areas)
        "isPortal": false,
        # exit offsets in list, sometimes there can be multiple exits to another map area
        "offsets": [{"x": 5672, "y": 5880}]
      }
    },
    # npcs on map
    "npcs": {
      # npc id is 147, with offset list so that there can be multiple npcs in the same id
      "147": [{"x": 5615, "y": 5967}]
    },
    # objects on map
    "objects": {
      # object id is 147, with offset list so that there can be multiple objects in the same id
      "119": [{"x": 5634, "y": 5889}]
    }
  }
  ```
* map data are encoded using a simple run length encoding to save memory space  
  -1 ends of a row  
  Given this small map:  
  ```
  [1,5,1,-1,
   2,3,2,-1,
   1,5,1,-1]
  ```

  Generates the following map where `X` is collision and `.` is open space
  ```
  X.....X
  XX...XX
  X.....X
  ```

# Build
* Just use [cmake](https://cmake.org) to build
  * Note: `d2mapapi`, `d2mapapi_httpd` and `d2mapapi_piped` can only be compiled in 32-bit.

# Credits
* Core functions modified from [d2mapapi](https://github.com/jcageman/d2mapapi).
* [JSON for Modern C++](https://github.com/nlohmann/json) for processing JSON files.
* [libuv](https://github.com/libuv/libuv) and [llhttp](https://github.com/nodejs/llhttp), for httpd server.
